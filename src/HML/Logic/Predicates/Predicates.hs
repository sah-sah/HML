{--
 -- Predicates.hs
 -- A module for predicate logic
 --
 -- Gives basic data types for predicate logic, show instances, construction functions
 -- and some examples.
 --}
module HML.Logic.Predicates.Predicates where

import Data.List(nub)
--import Control.Monad

{-
Use Hilbert style deductive system, with few inference rules and (infinitely) many axioms
generated by axiom schemas (there are some interesting ones in set theory, including the axiom of choice)
Inference rules:
forall x. P(x) => P(y) (where x,y are in some set U)
   This corresponds to saying Let y be aribtrary such that P(y)
P(y) => forall x. P(x) (where x,y are in some set U)
   This corresponds to saying, if P(y) is true for arbitrary y, then P(x) is true for all x
To prove T :: A -> B (where T is our set of axioms) we can prove T + A :: B
   This corresponds to saying, assume A, then showing B and concluding A -> B
Proof by contradiction if similar T + A :: False implies T :: A is false, not A is true
forall x. P(x) => exists y. P(y) if x ranges over U and y ranges over a superset of U
Modus ponens:: P(x) -> Q(x), P(x) allows us to conclude Q(x) - we can generalise this to
   forall x. P(x) -> Q(x), P(y) gives Q(y) (this is a combination of the previous steps)

It will be convenient to have other rules of inference, which follow from those above

-}

-- TODO: remove types
--       add indexed variables
--       implement the below
--       simplify predicate binding as described below
{-
data PName = PSimpleVar String
           | PIndexedVar String Expression
           | PConstant Special
           | NPatVar String
           | NCut

data Special = SInt Integer
             | SBool Bool
             | SZ
             | SZplus
             | SZn Expression
             | SFinite Expression

-- explicit equals function which we will use in the deduction laws
-- if x=y, then we can substitute y for each occurence of x in P
data Expression = ExpN PName
                | ExpFn PName [Expression]
                | ExpEquals Expression Expression
                | ExpPatVar String
                | ExpCut
-}

{- ---------- Data types ---------- -}

-- variables
data Variable = SimpleVar String
              | IndexedVar String Expression
              | VPatVar String
              | VCut
    deriving (Show, Eq)

-- Names of variables and constants etc
data Name = Var Variable
          | Constant Special
    deriving (Show, Eq)

-- Names of special mathematical objects
data Special = SInt Integer
             | SBool Bool
             | SZ
             | SZplus
             | SZn Expression -- {0,...,n-1} where n is given by an expression
             | SFinite Expression -- {1,...,n} where n is given by an expression
    deriving (Show, Eq)

-- general mathematical expressions, with equals a special case
data Expression = ExpN Name
                | ExpFn String [Expression]
                | ExpEquals Expression Expression
                | ExpPatVar String
                | ExpCut
    deriving (Show, Eq)

-- predicates which are expressions of type Bool
data Predicate = PExp Expression -- general form (the expression here should have type Bool)
               | PAnd Predicate Predicate
               | POr Predicate Predicate
               | PImp Predicate Predicate
               | PIff Predicate Predicate
               | PNot Predicate
               | PBinding BindingType Variable Predicate
               | PPatVar String -- for forming logic laws
               | PCut
    deriving (Show, Eq)

-- exists or forall
data BindingType = Forall | Exists
    deriving (Show, Eq)

{- ---------- Construction Functions ---------- -}


{-
forall, exists :: Variable -> Predicate -> Predicate
forall = PBinding Forall
exists = PBinding Exists
-}

{- ---------- Querying Predicates ---------- -}

getPatterns :: Predicate -> ([Predicate],[Expression],[Variable])
getPatterns = getPatternsP'
    where getPatternsP' (PExp e)         = getPatternsE' e
          getPatternsP' (PAnd p q)       = (getPatternsP' p) `join` (getPatternsP' q)
          getPatternsP' (POr p q)        = (getPatternsP' p) `join` (getPatternsP' q)
          getPatternsP' (PImp p q)       = (getPatternsP' p) `join` (getPatternsP' q)
          getPatternsP' (PIff p q)       = (getPatternsP' p) `join` (getPatternsP' q)
          getPatternsP' (PNot p)         = getPatternsP' p
          getPatternsP' (PBinding t v p) = (getPatternsV' v) `join` (getPatternsP' p)
          getPatternsP' (PPatVar n)      = ([PPatVar n],[],[])
          getPatternsP' _                = ([],[],[])

          getPatternsE' (ExpN n)        = getPatternsN' n
          getPatternsE' (ExpFn _ es)    = foldl join ([],[],[]) (map getPatternsE' es)
          getPatternsE' (ExpEquals e f) = (getPatternsE' e) `join` (getPatternsE' f)
          getPatternsE' (ExpPatVar n)   = ([],[ExpPatVar n],[])
          getPatternsE' _               = ([],[],[])

          getPatternsN' (Var v)      = getPatternsV' v
          getPatternsN' (Constant s) = getPatternsS' s

          getPatternsV' (IndexedVar n e) = getPatternsE' e
          getPatternsV' (VPatVar n)      = ([],[],[VPatVar n])
          getPatternsV' _                = ([],[],[])

          getPatternsS' (SZn e)     = getPatternsE' e
          getPatternsS' (SFinite e) = getPatternsE' e
          getPatternsS' _           = ([],[],[])

          join (ps,es,ns) (qs,fs,ms) = (nub (ps++qs), nub (es++fs), nub (ns++ms))

getVariables :: Predicate -> [Variable]
getVariables = nub . getVariablesP'
    where getVariablesP' (PExp e)         = getVariablesE' e
          getVariablesP' (PAnd p q)       = (getVariablesP' p) ++ (getVariablesP' q)
          getVariablesP' (POr p q)        = (getVariablesP' p) ++ (getVariablesP' q)
          getVariablesP' (PImp p q)       = (getVariablesP' p) ++ (getVariablesP' q)
          getVariablesP' (PIff p q)       = (getVariablesP' p) ++ (getVariablesP' q)
          getVariablesP' (PNot p)         = getVariablesP' p
          getVariablesP' (PBinding t v p) = v:((getVariablesV' v) ++ (getVariablesP' p))
          getVariablesP' _                = []
          
          getVariablesE' (ExpN n)        = getVariablesN' n
          getVariablesE' (ExpFn _ es)    = concatMap getVariablesE' es
          getVariablesE' (ExpEquals e f) = (getVariablesE' e) ++ (getVariablesE' f)
          getVariablesE' _               = []
          
          getVariablesN' (Var v)      = v:(getVariablesV' v)
          getVariablesN' (Constant s) = getVariablesS' s
          
          getVariablesV' (IndexedVar n e) = getVariablesE' e
          getVariablesV' _                = []
          
          getVariablesS' (SZn e)     = getVariablesE' e
          getVariablesS' (SFinite e) = getVariablesE' e
          getVariablesS' _           = []

-- isCompound? is for whether brackets are needed
isCompoundV :: Variable -> Bool
isCompoundV (SimpleVar _)    = False
isCompoundV (IndexedVar _ _) = False
isCompoundV (VPatVar _)      = False
isCompoundV (VCut)           = False

isCompoundN :: Name -> Bool
isCompoundN (Var v)      = isCompoundV v
isCompoundN (Constant s) = isCompoundS s

isCompoundS :: Special -> Bool
isCompoundS (SInt _)    = False
isCompoundS (SBool _)   = False
isCompoundS (SZ)        = False
isCompoundS (SZplus)    = False
isCompoundS (SZn _)     = False
isCompoundS (SFinite _) = False

isCompoundE :: Expression -> Bool
isCompoundE (ExpN n)        = isCompoundN n
isCompoundE (ExpFn _ _)     = True
isCompoundE (ExpEquals _ _) = True
isCompoundE (ExpPatVar _)   = False
isCompoundE (ExpCut)        = False

isCompoundP :: Predicate -> Bool
isCompoundP (PExp e)         = isCompoundE e
isCompoundP (PAnd _ _)       = True
isCompoundP (POr _ _)        = True
isCompoundP (PImp _ _)       = True
isCompoundP (PIff _ _)       = True
isCompoundP (PNot _)         = True
isCompoundP (PBinding _ _ _) = True
isCompoundP (PPatVar _)      = False
isCompoundP (PCut)           = False

{-
renameFreeVariable :: String -> String -> Predicate -> Maybe Predicate
-- would be easier if Predicate was a functor
-- renameFreeVariable xn yn p renames xn to yn in p p.v. yn does not occur in p
renameFreeVariable xn yn p = if yn `elem` getVariableNames p then Nothing else Just (renameP' p)
    where renameP' (PExp e)         = PExp (renameE' e)
          renameP' (PExpT e t)      = PExpT (renameE' e) t
          renameP' (PBinary op p q) = PBinary op (renameP' p) (renameP' q)
          renameP' (PUnary op p)    = PUnary op (renameP' p)
          renameP' (PBinding pb p)  = if captured' pb then PBinding pb p
                                                      else PBinding (renamePB' pb) (renameP' p)
          renameP' p                = p

          renamePB' (Forall pn p) = Forall (renamePN' pn) (renameP' p)
          renamePB' (Exists pn p) = Exists (renamePN' pn) (renameP' p)

          renameE' (ExpN pn)   = ExpN (renamePN' pn)
          renameE' (ExpF n es) = ExpF n (map renameE' es)
          renameE' e           = e

          renamePN' (PVar n) = PVar (if n == xn then yn else n)
          renamePN' pn       = pn

          captured' (Forall (PVar n) _) = n == xn
          captured' (Exists (PVar n) _) = n == xn
          captured' _                   = False

{-
renameBoundVariable :: String -> String -> Predicate -> Predicate
renameBoundVariable xn yn p@(PBinding (Forall (PVar n) q) r) | n == xn   = PBinding (Forall (PVar n) (renameFreeVariable xn yn q)) (renameFreeVariable xn yn r)
                                                             | otherwise = p
renameBoundVariable xn yn p@(PBinding (Exists (PVar n) q) r) | n == xn   = PBinding (Exists (PVar n) (renameFreeVariable xn yn q)) (renameFreeVariable xn yn r)
                                                             | otherwise = p
-}

varToPatterns :: Predicate -> Predicate
varToPatterns = vtpP'
    where vtpP' (PExp e)         = case vtpE' e of
                                     ExpPatVar n -> PPatVar n
                                     e'          -> PExp e'
          vtpP' (PExpT e t)      = PExpT (vtpE' e) t
          vtpP' (PBinary op p q) = PBinary op (vtpP' p) (vtpP' q)
          vtpP' (PUnary op p)    = PUnary op (vtpP' p)
          vtpP' (PBinding pb p)  = PBinding (vtpPB' pb) (vtpP' p)
          vtpP' p                = p

          vtpPB' (Forall pn p) = Forall (vtpPN' pn) (vtpP' p)
          vtpPB' (Exists pn p) = Exists (vtpPN' pn) (vtpP' p)

          vtpE' (ExpN pn)   = case vtpPN' pn of
                                NPatVar n -> ExpPatVar n
                                pn'       -> ExpN pn'
          vtpE' (ExpF n es) = ExpF n (map vtpE' es)
          vtpE' e           = e

          vtpPN' (PVar n) = NPatVar n
          vtpPN' pn       = pn
-}



{- ---------- Examples ---------- -}

{-
data Variable = SimpleVar String
              | IndexedVar String Expression
              | VPatVar String
              | VCut

data Name = Var Variable
          | Constant Special
    deriving (Show, Eq)

-- Names of special mathematical objects
data Special = SInt Integer
             | SBool Bool
             | SZ
             | SZplus
             | SZn Expression -- {0,...,n-1} where n is given by an expression
             | SFinite Expression
-}

-- variables
xVar, yVar :: Name
xVar = Var $ SimpleVar "x"
yVar = Var $ SimpleVar "y"
iVar = Var $ SimpleVar "i"
jVar = Var $ SimpleVar "j"
xiVar = Var (IndexedVar "x" (ExpN iVar))
xjVar = Var (IndexedVar "x" (ExpN jVar))
xnVar n = Var (IndexedVar "x" (ExpN (intn n)))
xnsVar n = Var (IndexedVar "x" (ExpN $ firstN n))
-- special constants
int1 = Constant (SInt 1)
intn n = Constant (SInt n)
true = Constant (SBool True)
false = Constant (SBool False)
ints = Constant (SZ)
posInts = Constant (SZplus)
firstN n = Constant (SFinite (ExpN $ intn n))
-- expressions
lt = ExpFn "numLT" [ExpN $ intn 2, ExpN $ intn 3]
eqxy = ExpEquals (ExpN xVar) (ExpN yVar)
-- predicates
andP = PAnd (PExp lt) (PExp eqxy)
distinct = PBinding Forall i (PBinding Forall j (PImp (PExp xieqxj) (PExp ieqj)))
    where i = SimpleVar "i"
          j = SimpleVar "j"
          xi = IndexedVar "x" (ExpN $ Var i)
          xj = IndexedVar "x" (ExpN $ Var j)

          ieqj = ExpEquals (ExpN $ Var i) (ExpN $ Var j)
          xieqxj = ExpEquals (ExpN $ Var xi) (ExpN $ Var xj)

