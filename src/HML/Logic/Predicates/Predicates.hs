{--
 -- Predicates.hs
 -- :l ./HML/Logic/PredicateLogic/Predicates.hs from devel directory
 -- A module for predicate logic
 --
 -- Gives basic data types for predicate logic, show instances, construction functions
 -- and some examples.
 --}
module HML.Logic.Predicates.Predicates where

import Data.List
import Control.Monad

{-
Use Hilbert style deductive system, with few inference rules and (infinitely) many axioms
generated by axiom schemas (there are some interesting ones in set theory, including the axiom of choice)
Inference rules:
forall x. P(x) => P(y) (where x,y are in some set U)
   This corresponds to saying Let y be aribtrary such that P(y)
P(y) => forall x. P(x) (where x,y are in some set U)
   This corresponds to saying, if P(y) is true for arbitrary y, then P(x) is true for all x
To prove T :: A -> B (where T is our set of axioms) we can prove T + A :: B
   This corresponds to saying, assume A, then showing B and concluding A -> B
Proof by contradiction if similar T + A :: False implies T :: A is false, not A is true
forall x. P(x) => exists y. P(y) if x ranges over U and y ranges over a superset of U
Modus ponens:: P(x) -> Q(x), P(x) allows us to conclude Q(x) - we can generalise this to
   forall x. P(x) -> Q(x), P(y) gives Q(y) (this is a combination of the previous steps)

It will be convenient to have other rules of inference, which follow from those above

We need a new proof calculus. let T be set of axioms. Then T :: A means A is true given T

In propositional logic we joined axioms using and then manipulated to get desired statement
This approach is too restrictive (and impractical) for predicate logic, we will need to 
maintain a collection of True statements A1,...,An. The axioms will be implied. Then we combine
axioms and previous statements to get An+1 etc. We can do subproofs, where we temporarily add
A to the axioms, then any statements B we derive, can be replaced with A -> B1, ..., A -> Bn etc

Our implementation of sets should (be some subset of?) ZFC. Just use a subset of sets available in ZFC.


-}


{- ---------- Data types ---------- -}

-- variables, constants, and functions can have multiple types 
data Type = AbstractSetT -- for abstract sets
          | PredicateT   -- essentially a boolean
          | EmptyT       -- no type information
    deriving (Eq)

-- the types of variables are given as predicates (i.e. A :: AbstractSetT is a predicate
-- which we use for matching, e.g., from x :: Integer and y=x^2 we can derive y :: Integer)
-- This datatype will need to be expanded, e.g. to (String,String) where the first
-- string is a unique identifier, and the second is how to display it
data PName = PVar String     -- variables x, A, etc
           | PConst String   -- constants 1, Z, True etc
           | PInt Integer
           | PTrue
           | PFalse
           | NPatVar String  -- for matching
    deriving (Eq)

-- an expression is either a type expression (x :: Integer) or a function expression (x + y)
data Expression = ExpN PName
                | ExpF String [Expression]
                | ExpPatVar String
                | ExpCut
    deriving (Eq)

-- binding a variable in a predicate
-- forall x s.t. P(x). Q(x) 
-- note: name must be a PVar
data PredicateBinding = Forall PName Predicate | Exists PName Predicate
    deriving (Eq)

data PBOp = PAnd | POr | PXOr | PImp | PIff
    deriving (Eq)

data PUOp = PNot
    deriving (Eq)

data Predicate = PEmpty
               | PExp Expression
               | PExpT Expression Type
               | PBinary PBOp Predicate Predicate
               | PUnary PUOp Predicate 
               | PBinding PredicateBinding Predicate
               | PPatVar String -- for forming logic laws
               | PCut
    deriving (Eq)

{- ---------- Show instances ---------- -}

-- TODO: for pretty printing we need a context with
-- information about the functions and how to print them

bracket :: Bool -> String -> String
bracket b str = if b then "(" ++ str ++ ")" else str

--TODO: rewrite the show instances to remove unnecessary brackets
-- but bracket everything without regard to precedence

-- use unicode to get nice characters
instance Show Type where
    show AbstractSetT = "Set"
    show PredicateT   = "P()"
    show EmptyT       = "()"

instance Show PName where
    show (PVar n)    = n
    show (PConst n)  = n
    show (PInt n)    = show n
    show (PTrue)     = "T"
    show (PFalse)    = "F"
    show (NPatVar n) = concat ["N{",n,"}"]

instance Show Expression where
    show (ExpN pn)     = show pn
    show (ExpF n es)   = intercalate " " (n:map bshow' es)
        where bshow' e = bracket (isCompoundExp e) (show e)
    show (ExpPatVar n) = concat ["E{",n,"}"] -- pattern variables are in curly brackets
    show (ExpCut)      = "(@)" -- must be in brackets

instance Show PredicateBinding where
    show (Forall v p) = "forall " ++ show v ++ (if p==PEmpty then [] else " s.t. " ++ show p) ++ "."
    show (Exists v p) = "exists " ++ show v ++ (if p==PEmpty then [] else " s.t. " ++ show p) ++ "."

instance Show PBOp where
    show PAnd = "&"
    show POr  = "|"
    show PXOr = "x|"
    show PImp = "->"
    show PIff = "<->"

instance Show PUOp where
    show PNot = "~"

instance Show Predicate where
    show (PEmpty)         = "()"
    show (PExp e)         = show e
    show (PExpT e t)      = intercalate " " [show e,"::",show t]
    show (PBinary op p q) = intercalate " " [bracket (isCompoundP p) (show p)
                                            ,show op
                                            ,bracket (isCompoundP q) (show q)]
    show (PUnary op p)    = intercalate " " [show op,bracket (isCompoundP p) (show p)]
    show (PBinding pb p)  = intercalate " " [show pb,show p]
    show (PPatVar n)      = concat ["P{",n,"}"] -- pattern variables in curly brackets
    show (PCut)           = "(@)" -- must be in brackets

{- ---------- Construction Functions ---------- -}

-- named objects (variables and constants)
varN, constN, patternN :: String -> PName
varN = PVar
constN = PConst
patternN = NPatVar

intN :: Integer -> PName
intN = PInt

trueN, falseN :: PName
trueN = PTrue
falseN = PFalse

hasPatternPN :: PName -> Bool
hasPatternPN (NPatVar _) = True
hasPatternPN _           = False

-- expressions
namedExp :: PName -> Expression
namedExp = ExpN

fnExp :: String -> [Expression] -> Expression
fnExp = ExpF

patternExp :: String -> Expression
patternExp = ExpPatVar

hasPatternExp :: Expression -> Bool
hasPatternExp (ExpN pn)     = hasPatternPN pn
hasPatternExp (ExpF _ es)   = any hasPatternExp es
hasPatternExp (ExpPatVar _) = True
hasPatternExp _             = False

-- predicates
emptyP :: Predicate
emptyP = PEmpty

isEmptyP :: Predicate -> Bool
isEmptyP (PEmpty) = True
isEmptyP _        = False

trueP, falseP :: Predicate
-- TODO: maybe these should be special values
trueP = expP $ namedExp trueN
falseP =  expP $ namedExp falseN

expP :: Expression -> Predicate
expP = PExp

typedExpP :: Expression -> Type -> Predicate
typedExpP = PExpT

andP, orP, xorP, impP, iffP :: Predicate -> Predicate -> Predicate
andP = PBinary PAnd
orP  = PBinary POr
xorP = PBinary PXOr
impP = PBinary PImp
iffP = PBinary PIff

notP :: Predicate -> Predicate
notP = PUnary PNot

patternP :: String -> Predicate
patternP = PPatVar

hasPatternP :: Predicate -> Bool
hasPatternP (PExp e)        = hasPatternExp e
hasPatternP (PExpT e t)     = hasPatternExp e
hasPatternP (PBinary _ p q) = hasPatternP p || hasPatternP q
hasPatternP (PUnary _ p)    = hasPatternP p
hasPatternP (PBinding pb p) = hasPatternPB pb || hasPatternP p
hasPatternP (PPatVar _)     = True
hasPatternP _               = False

forall, exists :: PName -> Predicate -> Predicate -> Predicate
forall n stp p = PBinding (Forall n stp) p
exists n stp p = PBinding (Exists n stp) p

forall_, exists_ :: PName -> Predicate -> Predicate
forall_ n p = PBinding (Forall n PEmpty) p
exists_ n p = PBinding (Exists n PEmpty) p

isBound :: PName -> Predicate -> Bool
--isBound pn p returns true if pn is bound in p
isBound pn (PBinary _ p q) = isBound pn p || isBound pn q
isBound pn (PUnary _ p)    = isBound pn p
isBound pn (PBinding pb p) = (boundVariable pb == pn) || isBound pn p
isBound pn _               = False

boundVariable :: PredicateBinding -> PName
boundVariable (Forall v _) = v
boundVariable (Exists v _) = v

hasPatternPB :: PredicateBinding -> Bool
hasPatternPB (Forall n p) = hasPatternPN n || hasPatternP p
hasPatternPB (Exists n p) = hasPatternPN n || hasPatternP p

getVariableNames :: Predicate -> [String]
--getVariables p returns the names of variables in p
--(whether the variables are bound or not)
getVariableNames = getVNamesP' 
    where getVNamesP' (PExp e)        = getVNamesE' e
          getVNamesP' (PExpT e _)     = getVNamesE' e
          getVNamesP' (PBinary _ p q) = getVNamesP' p ++ getVNamesP' q
          getVNamesP' (PUnary _ p)    = getVNamesP' p
          getVNamesP' (PBinding pb p) = getVNamesPB' pb ++ getVNamesP' p
          getVNamesP' _               = []

          getVNamesE' (ExpN pn)   = getVNamesPN' pn
          getVNamesE' (ExpF _ es) = concatMap getVNamesE' es
          getVNamesE' _           = []

          getVNamesPB' (Forall pn p) = getVNamesPN' pn ++ getVNamesP' p
          getVNamesPB' (Exists pn p) = getVNamesPN' pn ++ getVNamesP' p

          getVNamesPN' (PVar n) = [n]
          getVNamesPN' _        = []

getPatterns :: Predicate -> ([Predicate],[Expression],[PName])
getPatterns = getPatternsP'
    where getPatternsP' (PExp e)        = getPatternsE' e
          getPatternsP' (PExpT e _)     = getPatternsE' e
          getPatternsP' (PBinary _ p q) = (getPatternsP' p) `join'` (getPatternsP' q)
          getPatternsP' (PUnary _ p)    = getPatternsP' p
          getPatternsP' (PBinding pb p) = (getPatternsPB' pb) `join'` (getPatterns p)
          getPatternsP' (PPatVar n)     = ([PPatVar n],[],[])
          getPatternsP' _               = ([],[],[])

          getPatternsE' (ExpN pn)     = getPatternsPN' pn
          getPatternsE' (ExpF _ es)   = foldl join' ([],[],[]) (map getPatternsE' es)
          getPatternsE' (ExpPatVar n) = ([],[ExpPatVar n],[])
          getPatternsE' _             = ([],[],[])

          getPatternsPB' (Forall pn p) = (getPatternsPN' pn) `join'` (getPatternsP' p)
          getPatternsPB' (Exists pn p) = (getPatternsPN' pn) `join'` (getPatternsP' p)

          getPatternsPN' (NPatVar n) = ([],[],[NPatVar n])
          getPatternsPN' _           = ([],[],[])

          join' (ps,es,ns) (qs,fs,ms) = (nub (ps++qs), nub (es++fs), nub (ns++ms))

renameFreeVariable :: String -> String -> Predicate -> Predicate
-- would be easier if Predicate was a functor
renameFreeVariable xn yn p = renameP' p
    where renameP' (PExp e)         = PExp (renameE' e)
          renameP' (PExpT e t)      = PExpT (renameE' e) t
          renameP' (PBinary op p q) = PBinary op (renameP' p) (renameP' q)
          renameP' (PUnary op p)    = PUnary op (renameP' p)
          renameP' (PBinding pb p)  = if captured' pb then PBinding pb p
                                                      else PBinding (renamePB' pb) (renameP' p)
          renameP' p                = p

          renamePB' (Forall pn p) = Forall (renamePN' pn) (renameP' p)
          renamePB' (Exists pn p) = Exists (renamePN' pn) (renameP' p)

          renameE' (ExpN pn)   = ExpN (renamePN' pn)
          renameE' (ExpF n es) = ExpF n (map renameE' es)
          renameE' e           = e

          renamePN' (PVar n) = PVar (if n == xn then yn else n)
          renamePN' pn       = pn

          captured' (Forall (PVar n) _) = n == xn
          captured' (Exists (PVar n) _) = n == xn
          captured' _                   = False

renameBoundVariable :: String -> String -> Predicate -> Predicate
renameBoundVariable xn yn p@(PBinding (Forall (PVar n) q) r) | n == xn   = PBinding (Forall (PVar n) (renameFreeVariable xn yn q)) (renameFreeVariable xn yn r)
                                                             | otherwise = p
renameBoundVariable xn yn p@(PBinding (Exists (PVar n) q) r) | n == xn   = PBinding (Exists (PVar n) (renameFreeVariable xn yn q)) (renameFreeVariable xn yn r)
                                                             | otherwise = p

varToPatterns :: Predicate -> Predicate
varToPatterns = vtpP'
    where vtpP' (PExp e)         = case vtpE' e of
                                     ExpPatVar n -> PPatVar n
                                     e'          -> PExp e'
          vtpP' (PExpT e t)      = PExpT (vtpE' e) t
          vtpP' (PBinary op p q) = PBinary op (vtpP' p) (vtpP' q)
          vtpP' (PUnary op p)    = PUnary op (vtpP' p)
          vtpP' (PBinding pb p)  = PBinding (vtpPB' pb) (vtpP' p)
          vtpP' p                = p

          vtpPB' (Forall pn p) = Forall (vtpPN' pn) (vtpP' p)
          vtpPB' (Exists pn p) = Exists (vtpPN' pn) (vtpP' p)

          vtpE' (ExpN pn)   = case vtpPN' pn of
                                NPatVar n -> ExpPatVar n
                                pn'       -> ExpN pn'
          vtpE' (ExpF n es) = ExpF n (map vtpE' es)
          vtpE' e           = e

          vtpPN' (PVar n) = NPatVar n
          vtpPN' pn       = pn

{- ---------- Building Set Expressions ----------- -}
{- TODO: these should be in Axioms.Set -}
emptySet :: Expression
emptySet = namedExp $ constN "0"

isASet :: PName -> Predicate
isASet n = typedExpP (namedExp n) AbstractSetT

intersection, union, subset, equalSet, symDiff, diff, cross :: Expression -> Expression -> Expression
intersection a b = ExpF "setIntersection" [a,b]
union a b = ExpF "setUnion" [a,b]
subset a b = ExpF "setSubset" [a,b]
equalSet a b = ExpF "setEqual" [a,b]
symDiff a b = ExpF "setSymmetricDifference" [a,b]
diff a b = ExpF "setDifference" [a,b]
cross a b = ExpF "setCrossProduct" [a,b]

complement :: Expression -> Expression 
complement a = ExpF "setComplement" [a]

inSet :: Expression -> Expression -> Expression
inSet e se = ExpF "setElem" [e,se]


isCompoundPN :: PName -> Bool
-- currently there are no compound PNames
isCompoundPN _ = False

isCompoundT :: Type -> Bool
isCompoundT _ = False

isCompoundExp :: Expression -> Bool
isCompoundExp (ExpN pn)     = isCompoundPN pn
-- sometimes we need brackets, other times not 
isCompoundExp (ExpF _ _)    = True
isCompoundExp (ExpPatVar _) = False
isCompoundExp (ExpCut)      = False

isCompoundP :: Predicate -> Bool
isCompoundP (PEmpty) = False
isCompoundP (PExp e) = isCompoundExp e
isCompoundP (PExpT e t) = True
isCompoundP (PBinary op p q) = True
isCompoundP (PUnary op p) = True
isCompoundP (PBinding pb p) = True
isCompoundP (PPatVar n) = False
isCompoundP (PCut) = False

{- ---------- Examples ---------- -}

-- definition of subset
subsetDefn :: Predicate
-- note: we will need extra predicates to make this useful
-- e.g. setA is a Set, setB is a Set, 
-- then these imply that setA `subset` setB has type PredicateT (Bool)
-- A logic law will involve matching at least one, but maybe more, predicates
-- e.g. to use subsetDefn we need to match A is a Set, B is a Set, A subset B
subsetDefn = iffP (expP $ (setA `subset` setB))
                  (forall_ nameX ((expP $ inSet varX setA) `impP` (expP $ inSet varX setB)))
    where setA = namedExp $ varN "A"
          setB = namedExp $ varN "B"

          nameX = varN "x"
          varX = namedExp nameX

setEqDefn :: Predicate
setEqDefn = iffP (expP $ (setA `equalSet` setB))
                 (andP (expP $ (setA `subset` setB))
                       (expP $ (setB `subset` setA)))
    where setA = namedExp $ varN "A"
          setB = namedExp $ varN "B"

