{--
 -- Predicates.hs
 -- A module for predicate logic
 --
 -- Gives basic data types for predicate logic, show instances, construction functions
 -- and some examples.
 --}
module HML.Logic.Predicates.Predicates where

import Data.List(nub)
--import Control.Monad
import Control.Applicative((<$>),(<*>))

{-
Use Hilbert style deductive system, with few inference rules and (infinitely) many axioms
generated by axiom schemas (there are some interesting ones in set theory, including the axiom of choice)
Inference rules:
forall x. P(x) => P(y) (where x,y are in some set U)
   This corresponds to saying Let y be aribtrary such that P(y)
P(y) => forall x. P(x) (where x,y are in some set U)
   This corresponds to saying, if P(y) is true for arbitrary y, then P(x) is true for all x
To prove T :: A -> B (where T is our set of axioms) we can prove T + A :: B
   This corresponds to saying, assume A, then showing B and concluding A -> B
Proof by contradiction if similar T + A :: False implies T :: A is false, not A is true
forall x. P(x) => exists y. P(y) if x ranges over U and y ranges over a superset of U
Modus ponens:: P(x) -> Q(x), P(x) allows us to conclude Q(x) - we can generalise this to
   forall x. P(x) -> Q(x), P(y) gives Q(y) (this is a combination of the previous steps)

It will be convenient to have other rules of inference, which follow from those above

-}

-- TODO: remove types
--       add indexed variables
--       implement the below
--       simplify predicate binding as described below
{-
data PName = PSimpleVar String
           | PIndexedVar String Expression
           | PConstant Special
           | NPatVar String
           | NCut

data Special = SInt Integer
             | SBool Bool
             | SZ
             | SZplus
             | SZn Expression
             | SFinite Expression

-- explicit equals function which we will use in the deduction laws
-- if x=y, then we can substitute y for each occurence of x in P
data Expression = ExpN PName
                | ExpFn PName [Expression]
                | ExpEquals Expression Expression
                | ExpPatVar String
                | ExpCut
-}

{- ---------- Data types ---------- -}

{- We should probably use
data Name = SimpleVar Variable
          | IndexedVar Variable Expression
          | Constant Special
          | NCut

data Variable = V String | VPatVar String

maybe Special should have SCustom String option
-}

-- variables
data Variable = SimpleVar String
              | IndexedVar String Expression
              | VPatVar String
              | VCut
    deriving (Show, Eq)

-- Names of variables and constants etc
data Name = Var Variable
          | Constant Special
    deriving (Show, Eq)

-- Names of special mathematical objects
-- might need more general set expressions
-- {2,...,4}, {x \in A | P(x) }
-- these can be added as functions though
-- these can just be part of the parser then represented as functions
-- ???: Should we have a separate SetExpression type?
data Special = SInt Integer
             | SBool Bool
             | SEmptySet
             | SZ
             | SZplus
             | SZn Expression -- {0,...,n-1} where n is given by an expression
             | SFinite Expression -- {1,...,n} where n is given by an expression
    deriving (Show, Eq)

-- general mathematical expressions, with equals a special case
-- TODO: should we make function names a Variable
data Expression = ExpN Name
                | ExpFn String [Expression]
                | ExpEquals Expression Expression
                | ExpPatVar String
                | ExpCut
    deriving (Show, Eq)

-- predicates which are expressions of type Bool
data Predicate = PExp Expression -- general form (the expression here should have type Bool)
               | PAnd Predicate Predicate
               | POr Predicate Predicate
               | PImp Predicate Predicate
               | PIff Predicate Predicate
               | PNot Predicate
               | PBinding BindingType Variable Predicate
               | PPatVar String -- for forming logic laws
               | PCut
    deriving (Show, Eq)

-- exists or forall
data BindingType = Forall | Exists
    deriving (Show, Eq)

{- ---------- Construction Functions ---------- -}


{-
forall, exists :: Variable -> Predicate -> Predicate
forall = PBinding Forall
exists = PBinding Exists
-}

{- ---------- Querying Predicates ---------- -}

getPatterns :: Predicate -> ([Predicate],[Expression],[Variable])
getPatterns = getPatternsP'
    where getPatternsP' (PExp e)         = getPatternsE' e
          getPatternsP' (PAnd p q)       = (getPatternsP' p) `join` (getPatternsP' q)
          getPatternsP' (POr p q)        = (getPatternsP' p) `join` (getPatternsP' q)
          getPatternsP' (PImp p q)       = (getPatternsP' p) `join` (getPatternsP' q)
          getPatternsP' (PIff p q)       = (getPatternsP' p) `join` (getPatternsP' q)
          getPatternsP' (PNot p)         = getPatternsP' p
          getPatternsP' (PBinding t v p) = (getPatternsV' v) `join` (getPatternsP' p)
          getPatternsP' (PPatVar n)      = ([PPatVar n],[],[])
          getPatternsP' _                = ([],[],[])

          getPatternsE' (ExpN n)        = getPatternsN' n
          getPatternsE' (ExpFn _ es)    = foldl join ([],[],[]) (map getPatternsE' es)
          getPatternsE' (ExpEquals e f) = (getPatternsE' e) `join` (getPatternsE' f)
          getPatternsE' (ExpPatVar n)   = ([],[ExpPatVar n],[])
          getPatternsE' _               = ([],[],[])

          getPatternsN' (Var v)      = getPatternsV' v
          getPatternsN' (Constant s) = getPatternsS' s

          getPatternsV' (IndexedVar n e) = getPatternsE' e
          getPatternsV' (VPatVar n)      = ([],[],[VPatVar n])
          getPatternsV' _                = ([],[],[])

          getPatternsS' (SZn e)     = getPatternsE' e
          getPatternsS' (SFinite e) = getPatternsE' e
          getPatternsS' _           = ([],[],[])

          join (ps,es,ns) (qs,fs,ms) = (nub (ps++qs), nub (es++fs), nub (ns++ms))

getVariables :: Predicate -> [Variable]
getVariables = nub . getVariablesP'
    where getVariablesP' (PExp e)         = getVariablesE' e
          getVariablesP' (PAnd p q)       = (getVariablesP' p) ++ (getVariablesP' q)
          getVariablesP' (POr p q)        = (getVariablesP' p) ++ (getVariablesP' q)
          getVariablesP' (PImp p q)       = (getVariablesP' p) ++ (getVariablesP' q)
          getVariablesP' (PIff p q)       = (getVariablesP' p) ++ (getVariablesP' q)
          getVariablesP' (PNot p)         = getVariablesP' p
          getVariablesP' (PBinding t v p) = v:((getVariablesV' v) ++ (getVariablesP' p))
          getVariablesP' _                = []
          
          getVariablesE' (ExpN n)        = getVariablesN' n
          getVariablesE' (ExpFn _ es)    = concatMap getVariablesE' es
          getVariablesE' (ExpEquals e f) = (getVariablesE' e) ++ (getVariablesE' f)
          getVariablesE' _               = []
          
          getVariablesN' (Var v)      = v:(getVariablesV' v)
          getVariablesN' (Constant s) = getVariablesS' s
          
          getVariablesV' (IndexedVar n e) = getVariablesE' e
          getVariablesV' _                = []
          
          getVariablesS' (SZn e)     = getVariablesE' e
          getVariablesS' (SFinite e) = getVariablesE' e
          getVariablesS' _           = []

variableString :: Variable -> Maybe String
variableString (SimpleVar n)    = Just n
variableString (IndexedVar n _) = Just n
variableString _                = Nothing

-- isCompound? is for whether brackets are needed
isCompoundV :: Variable -> Bool
isCompoundV (SimpleVar _)    = False
isCompoundV (IndexedVar _ _) = False
isCompoundV (VPatVar _)      = False
isCompoundV (VCut)           = False

isCompoundN :: Name -> Bool
isCompoundN (Var v)      = isCompoundV v
isCompoundN (Constant s) = isCompoundS s

isCompoundS :: Special -> Bool
isCompoundS (SInt _)    = False
isCompoundS (SBool _)   = False
isCompoundS (SEmptySet) = False
isCompoundS (SZ)        = False
isCompoundS (SZplus)    = False
isCompoundS (SZn _)     = False
isCompoundS (SFinite _) = False

isCompoundE :: Expression -> Bool
isCompoundE (ExpN n)        = isCompoundN n
isCompoundE (ExpFn _ _)     = True
isCompoundE (ExpEquals _ _) = True
isCompoundE (ExpPatVar _)   = False
isCompoundE (ExpCut)        = False

isCompoundP :: Predicate -> Bool
isCompoundP (PExp e)         = isCompoundE e
isCompoundP (PAnd _ _)       = True
isCompoundP (POr _ _)        = True
isCompoundP (PImp _ _)       = True
isCompoundP (PIff _ _)       = True
isCompoundP (PNot _)         = True
isCompoundP (PBinding _ _ _) = True
isCompoundP (PPatVar _)      = False
isCompoundP (PCut)           = False

renameFreeVariable :: String -> String -> Predicate -> Maybe Predicate
-- rename variable strings from xStr to yStr if yStr does not already appear in p
renameFreeVariable xStr yStr p = if yStr `elem` (maybe [] id (mapM variableString $ getVariables p))
                                 then Nothing
                                 else Just (renameP p)
    where renameP (PExp e)         = PExp $ renameE e
          renameP (PAnd p q)       = PAnd (renameP p) (renameP q)
          renameP (POr p q)        = POr (renameP p) (renameP q)
          renameP (PImp p q)       = PImp (renameP p) (renameP q)
          renameP (PIff p q)       = PIff (renameP p) (renameP q)
          renameP (PNot p)         = PNot $ renameP p
          renameP (PBinding t v p) = PBinding t (renameV v) (renameP p)
          renameP p                = p

          renameE (ExpN n)        = ExpN $ renameN n
          renameE (ExpFn n es)    = ExpFn n $ map renameE es
          renameE (ExpEquals e f) = ExpEquals (renameE e) (renameE f)
          renameE e               = e

          renameN (Var v)      = Var $ renameV v
          renameN (Constant s) = Constant $ renameS s

          renameV (SimpleVar n)    | n == xStr = SimpleVar yStr
                                   | otherwise = SimpleVar n
          renameV (IndexedVar n e) | n == xStr = IndexedVar yStr (renameE e)
                                   | otherwise = IndexedVar n (renameE e)
          renameV v                            = v

          renameS (SZn e)     = SZn $ renameE e
          renameS (SFinite e) = SFinite $ renameE e
          renameS s           = s


renameBoundVariable :: String -> String -> Predicate -> Maybe Predicate
renameBoundVariable xn yn (PBinding t (SimpleVar n) p) | xn == n   = do p' <- renameFreeVariable xn yn p
                                                                        return $ PBinding t (SimpleVar yn) p'
                                                       | otherwise = Nothing
renameBoundVariable xn yn (PBinding t (IndexedVar n e) p) | xn == n   = do p' <- renameFreeVariable xn yn p
                                                                           return $ PBinding t (IndexedVar yn e) p'
                                                          | otherwise = Nothing

-- we only change SimpleVar's and if there are IndexedVar's then return Nothing
-- this is not sufficient, if we have ExpN $ Var $ VPatVar we should use ExpPatVar and same for PPatVar
mkPatterns :: Predicate -> Maybe Predicate
mkPatterns = vtpP
    where vtpP (PExp e)         = PExp <$> vtpE e
          vtpP (PAnd p q)       = PAnd <$> (vtpP p) <*> (vtpP q)
          vtpP (POr p q)        = POr  <$> (vtpP p) <*> (vtpP q)
          vtpP (PImp p q)       = PImp <$> (vtpP p) <*> (vtpP q)
          vtpP (PIff p q)       = PIff <$> (vtpP p) <*> (vtpP q)
          vtpP (PNot p)         = PNot <$> vtpP p
          vtpP (PBinding t v p) = (PBinding t) <$> (vtpV v) <*> (vtpP p)
          vtpP p                = Just p

          vtpE (ExpN n)        = ExpN <$> vtpN n
          vtpE (ExpFn n es)    = (ExpFn n) <$> mapM vtpE es
          vtpE (ExpEquals e f) = ExpEquals <$> (vtpE e) <*> (vtpE f)
          vtpE e               = Just e

          vtpN (Var v)      = Var <$> vtpV v
          vtpN (Constant s) = Constant <$> vtpS s

          vtpV (SimpleVar n)    = Just $ VPatVar n
          vtpV (IndexedVar n e) = Nothing
          vtpV v                = Just v

          vtpS (SZn e)     = SZn <$> vtpE e
          vtpS (SFinite e) = SFinite <$> vtpE e
          vtpS s           = Just s


{- ---------- Examples ---------- -}

{-
data Variable = SimpleVar String
              | IndexedVar String Expression
              | VPatVar String
              | VCut

data Name = Var Variable
          | Constant Special
    deriving (Show, Eq)

-- Names of special mathematical objects
data Special = SInt Integer
             | SBool Bool
             | SZ
             | SZplus
             | SZn Expression -- {0,...,n-1} where n is given by an expression
             | SFinite Expression
-}

-- variables
xVar, yVar :: Name
xVar = Var $ SimpleVar "x"
yVar = Var $ SimpleVar "y"
iVar = Var $ SimpleVar "i"
jVar = Var $ SimpleVar "j"
xiVar = Var (IndexedVar "x" (ExpN iVar))
xjVar = Var (IndexedVar "x" (ExpN jVar))
xnVar n = Var (IndexedVar "x" (ExpN (intn n)))
xnsVar n = Var (IndexedVar "x" (ExpN $ firstN n))
-- special constants
int1 = Constant (SInt 1)
intn n = Constant (SInt n)
true = Constant (SBool True)
false = Constant (SBool False)
ints = Constant (SZ)
posInts = Constant (SZplus)
firstN n = Constant (SFinite (ExpN $ intn n))
-- expressions
lt = ExpFn "numLT" [ExpN $ intn 2, ExpN $ intn 3]
eqxy = ExpEquals (ExpN xVar) (ExpN yVar)
-- predicates
andP = PAnd (PExp lt) (PExp eqxy)
distinct = PBinding Forall i (PBinding Forall j (PImp (PExp xieqxj) (PExp ieqj)))
    where i = SimpleVar "i"
          j = SimpleVar "j"
          xi = IndexedVar "x" (ExpN $ Var i)
          xj = IndexedVar "x" (ExpN $ Var j)

          ieqj = ExpEquals (ExpN $ Var i) (ExpN $ Var j)
          xieqxj = ExpEquals (ExpN $ Var xi) (ExpN $ Var xj)

